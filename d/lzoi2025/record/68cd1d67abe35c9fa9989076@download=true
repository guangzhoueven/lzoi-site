#include <bits/stdc++.h>
using namespace std;
using i64 = long long;
const i64 MOD = 1e9 + 9;

struct SegmentTree {
	int n;
	vector<i64> t;

	SegmentTree(int n_) {
		n = n_;
		t.assign(2 * n, 0);
	}

	void update(int p, i64 v) {
		p += n, t[p] = (t[p] + v) % MOD;
		for (int i = p / 2; i >= 1; i /= 2) {
			t[i] = (t[i * 2] + t[i * 2 + 1]) % MOD;
		}
	}

	i64 query(int L, int R) {
		L += n, R += n;
		i64 ans = 0;
		while (L <= R) {
			if (L % 2 == 1) ans = (ans + t[L]) % MOD, L++;
			if (R % 2 == 0) ans = (ans + t[R]) % MOD, R--;
			L /= 2, R /= 2;
		}
		return ans;
	}
};

int main() {
	ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr);
	i64 n;
	cin >> n;
	vector<i64> a(n);
	for (int i = 0; i < n; i++) cin >> a[i];

	vector<i64> prefix(n + 1);
	prefix[0] = 0;
	for (int i = 1; i <= n; i++) {
		prefix[i] = prefix[i - 1] + a[i - 1];
	}

	vector<i64> sort_prefix = prefix;
	sort(sort_prefix.begin(), sort_prefix.end());
	sort_prefix.erase(unique(sort_prefix.begin(), sort_prefix.end()), sort_prefix.end());
	int m = sort_prefix.size();

	auto get_num = [&](i64 x) -> i64 {
		return lower_bound(sort_prefix.begin(), sort_prefix.end(), x) - sort_prefix.begin();
	};

	SegmentTree seg(m);
	vector<i64> dp(n + 1);

	dp[0] = 1;
	seg.update(get_num(prefix[0]), 1);

	for (int i = 1; i <= n; i++) {
		int num = get_num(prefix[i]);
		dp[i] = seg.query(0, num);
		seg.update(num, dp[i]);
	}
	cout << (dp[n] % MOD + MOD) % MOD << "\n";
	return 0;
}