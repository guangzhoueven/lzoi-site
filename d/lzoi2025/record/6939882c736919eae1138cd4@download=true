#include <bits/stdc++.h>
using namespace std;
using i64 = long long;

int main() {
	ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr);
	i64 n;
	cin >> n;
	vector<i64> x(n), y(n), px(n), py(n);
	for (i64 i = 0; i < n; i++) {
		cin >> x[i] >> y[i];
		px[i] = x[i], py[i] = y[i];
	}

	sort(x.begin(), x.end());						// 离散化
	sort(y.begin(), y.end());						// 离散化
	x.erase(unique(x.begin(), x.end()), x.end());	// unique可以实现去重
	y.erase(unique(y.begin(), y.end()), y.end());	// unique可以实现去重

	i64 ex = x.size(), ey = y.size();
	for (i64 i = 0; i < n; i++) {
		px[i] = lower_bound(x.begin(), x.end(), px[i]) - x.begin() + 1;
		py[i] = lower_bound(y.begin(), y.end(), py[i]) - y.begin() + 1;
	}


	// 二维前缀和
	vector<vector<i64>> p(ex + 1, vector<i64>(ey + 1));
	for (i64 i = 0; i < n; i++) p[px[i]][py[i]] = 1;
	for (i64 i = 1; i <= ex; i++) {
		for (i64 j = 1; j <= ey; j++)
			p[i][j] = p[i - 1][j] + p[i][j - 1] - p[i - 1][j - 1] + p[i][j];
	}

	auto calc = [&](i64 x1, i64 y1, i64 x2, i64 y2) -> i64 {
		return p[x2][y2] - p[x2][y1 - 1] - p[x1 - 1][y2] + p[x1 - 1][y1 - 1];
	};

	i64 ans = n;
	for (i64 i = 1; i < ex; i++) {
		for (i64 j = 1; j < ey; j++) {
			i64 c1 = calc(1, 1, i, j),
			    c2 = calc(i + 1, 1, ex, j),
			    c3 = calc(1, j + 1, i, ey),
			    c4 = calc(i + 1, j + 1, ex, ey);
			ans = min(ans, max({c1, c2, c3, c4}));
		}
	}
	cout << ans << "\n";
	return 0;
}