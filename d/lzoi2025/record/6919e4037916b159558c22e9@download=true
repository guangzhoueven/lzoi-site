#include <bits/stdc++.h>
using namespace std;
using i64 = long long;

int main() {
	ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr);
	i64 n;
	cin >> n;
	vector<i64> a(n);
	for (auto& x : a) cin >> x;
	
	vector<i64> pre(n + 1);
	for (i64 i = 0; i < n; i++) pre[i + 1] = pre[i] + a[i];
	
	vector<i64> L_ma(n), R_ma(n);       // 情况1：不跨越首尾，两段最大子段和
	i64 ma = a[0];
	L_ma[0] = a[0];                     // 从左往右的最大子段和
	for (i64 i = 1; i < n; i++) {    
		ma = max(a[i], ma + a[i]);
		L_ma[i] = max(L_ma[i - 1], ma);
	}
	
	ma = a[n - 1];                     // 从右往左的最大子段和
	R_ma[n - 1] = a[n - 1];
	for (i64 i = n - 2; i >= 0; i--) {
		ma = max(a[i], ma + a[i]);
		R_ma[i] = max(R_ma[i + 1], ma);
	}
	
	i64 ans1 = LLONG_MIN;
	for (i64 i = 0; i < n - 1; i++) 
		ans1 = max(ans1, L_ma[i] + R_ma[i + 1]);
	
	vector<i64> L_mi(n), R_mi(n);    // 情况2：跨越首尾，总和减去中间两段最小子段和
	i64 mi = a[0];                      // 从左往右的最小子段和
	L_mi[0] = a[0];
	for (i64 i = 1; i < n; i++) {
		mi = min(a[i], mi + a[i]);
		L_mi[i] = min(L_mi[i - 1], mi);
	}
	
	mi = a[n - 1];                  // 从右往左的最小子段和
	R_mi[n - 1] = a[n - 1];
	for (i64 i = n - 2; i >= 0; i--) {
		mi = min(a[i], mi + a[i]);
		R_mi[i] = min(R_mi[i + 1], mi);
	}
	
	i64 ans2 = LLONG_MAX;
	for (i64 i = 0; i < n - 1; i++) 
		ans2 = min(ans2, L_mi[i] + R_mi[i + 1]);
	
	ans2 = pre[n] - ans2;
	
	i64 ma1 = LLONG_MIN, ma2 = LLONG_MIN;    // 特殊情况：全负数
	for (auto x : a) {
		if (x > ma1) {
			ma2 = ma1;
			ma1 = x;
		} else if (x > ma2) ma2 = x;
	}
	
	cout << (ma1 < 0 ? ma1 + ma2 : max(ans1, ans2)) << "\n";
	return 0;
}
