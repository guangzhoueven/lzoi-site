#include <bits/stdc++.h>
using namespace std;
using i64 = long long;

// 约瑟夫环递推公式：f(n) = (f(n-1) + m) % n，其中f(1)=0
i64 solve(i64 n, i64 k, i64 m) {   	// 标准数学公式法（时间复杂度O(n)，适合n≤1e6）
	i64 ans = 0;  					// f(1) = 0，只有1个人时幸存者编号为0
	for (i64 i = 2; i <= n; i++)
		ans = (ans + m) % i;  		// 递推计算f(i)
	return (ans + k) % n;     		// 调整起始位置k
}

i64 solve2(i64 n, i64 k, i64 m) {	// 超大规模：优化数学公式法（时间复杂度O(mlogn)，适合n≤1e18）
	i64 ans = 0;  					// 初始化，f(1)=0
	i64 i = 2;    					// 从2个人开始递推
	while (i <= n) {				// 计算可跳跃的步数，加速递推过程
		i64 steps = min(n - i + 1, (i - ans + m - 2) / m);// steps = min(剩余步数, 可安全跳跃的步数)
		if (steps <= 0) steps = 1;  // 确保至少前进一步
		ans = (ans + m * steps) % (i + steps - 1);
		i += steps;
	}
	return (ans + k) % n;  			// 调整起始位置k
}

int main() {
	ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr);
	i64 T;
	cin >> T;
	while (T--) {
		i64 n, k, m;  // 人数n, 起始位置k, 报数间隔m
		cin >> n >> k >> m;
		i64 ans;
		if (n <= 1000000) ans = solve(n, k, m);   	// 标准数学法
		else ans = solve2(n, k, m);  				// 优化数学法		
		cout << ans << "\n";
	}
	return 0;
}