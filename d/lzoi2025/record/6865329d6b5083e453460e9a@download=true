
#include <iostream>
#include <vector>
#include <algorithm>
#include <unordered_set>
using namespace std;

struct Pair {
    int a_idx;
    int b_idx;
    bool operator==(const Pair& other) const {
        return a_idx == other.a_idx && b_idx == other.b_idx;
    }
};

struct PairHash {
    size_t operator()(const Pair& p) const {
        return hash<int>()(p.a_idx) ^ hash<int>()(p.b_idx);
    }
};

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    
    int n, m, L;
    cin >> n >> m >> L;
    
    vector<pair<int, int>> a(n), b(m);
    for (int i = 0; i < n; ++i) {
        cin >> a[i].first;
        a[i].second = i + 1;
    }
    for (int i = 0; i < m; ++i) {
        cin >> b[i].first;
        b[i].second = i + 1;
    }
    
    unordered_set<Pair, PairHash> forbidden;
    for (int i = 0; i < L; ++i) {
        int x, y;
        cin >> x >> y;
        forbidden.insert({x, y});
    }
    
    // 按值降序排序，保留原始索引
    sort(a.begin(), a.end(), [](const auto& p1, const auto& p2) {
        return p1.first > p2.first;
    });
    sort(b.begin(), b.end(), [](const auto& p1, const auto& p2) {
        return p1.first > p2.first;
    });
    
    int max_sum = 0;
    // 检查前k个可能的组合，k可以适当调整
    const int k = 100;
    for (int i = 0; i < min(k, n); ++i) {
        for (int j = 0; j < min(k, m); ++j) {
            if (forbidden.count({a[i].second, b[j].second}) == 0) {
                max_sum = max(max_sum, a[i].first + b[j].first);
            }
        }
    }
    
    cout << max_sum << endl;
    return 0;
}
