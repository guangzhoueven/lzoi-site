#include <bits/stdc++.h>
using namespace std;
template <typename T>

struct Graph {
	int n;                              // 谷仓数n
	vector<vector<pair<int, T>>> g;     // 邻接表（节点u，边权w）
	vector<T> d;                        // 最短距离
	vector<bool> visited;               // 状态标记

	Graph(int n_) : n(n_) {
		g.resize(n + 1);                // 1-based
		d.assign(n + 1, INT_MAX);
		visited.assign(n + 1, false);
	}

	void add_edge(int u, int v, T w = 1, bool p = false) { // w =1 固定，p控制双向（p=false为默认单向（有向图），p = true为双向（无向图））
		g[u].push_back({v, w});  				// 构建 u -> v 的边（边权w）【有向图单边】
		if (p == true) g[v].push_back({u, w});	// 构建 v -> u 的边（边权w）【无向图双边】
	}

	void Dijkstra_heap(int st) {
		using Node = pair<T, int>;
		priority_queue<Node, vector<Node>, greater<Node >> q; // 最小堆
		q.push({(d[st] = 0), st});				// 宴会在起点st，边权成本0
		visited[st] = true;						// 起点状态标记

		while (!q.empty()) {
			auto [dist_u, u] = q.top();
			q.pop();
			visited[u] = true;

			for (auto [v, w] : g[u]) {
				if (d[v] > d[u] + w) {
					d[v] = d[u] + w;
					q.push({d[v], v});
					visited[v] = true;
				}
			}
		}
	}
};

int main() {
	ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr);
	int n, m, k, s;
	cin >> n >> m >> k >> s;

	vector<int> a(n + 1);               	// 谷仓i的干草类型a_i
	vector<vector<int>> barns_tp(k + 1); 	// 每种干草对应的谷仓列表
	Graph<int> G(n);

	for (int i = 1; i <= n; i++) {
		cin >> a[i];
		barns_tp[a[i]].push_back(i);
	}

	while (m--) {
		int u, v;
		cin >> u >> v;
		G.add_edge(u, v, 1, true);      // 双向道路，边权固定w=1
	}

	vector<vector<int>> dist(k + 1, vector<int>(n + 1, INT_MAX));	// 每种干草类型到所有谷仓的最短距离
	for (int tp = 1; tp <= k; tp++) {		// 共有k种干草
		Graph<int> tempG = G;
		for (int barn : barns_tp[tp])
			tempG.add_edge(0, barn, 0); 	// 超级源点0 到 该类型所有谷仓

		tempG.Dijkstra_heap(0);				// 从虚拟构建的超级源点 0 开始
		dist[tp] = tempG.d;
	}

	for (int i = 1; i <= n; i++) {	// 计算每个谷仓i的最小总成本
		vector<int> costs;
		for (int tp = 1; tp <= k; tp++)
			if (tp != a[i]) costs.push_back(dist[tp][i]);

		// nth_element(costs.begin(),k,costs.end())主要功能是将序列中第 k 小的元素放到第 k 个位置上，
		// 重新排序,并且保证所有在它之前的元素都不大于它，所有在它之后的元素都不小于它【快速排序插入】
		nth_element(costs.begin(), costs.begin() + s - 1, costs.end());   // 插入第 s 个数到数组中并自动排列

		// accumulate(costs.begin(),costs.begin(),初始值,自定义函数(如累加、累乘等)),如果第四参数缺失（累积），则默认初始值范围 [first, last) 的第1个元素进行累加
		// 用于对容器内元素进行累加或其他自定义操作的函数
		cout << accumulate(costs.begin(), costs.begin() + s - 1, 0) << " \n"[i == n];
	}
	return 0;
}