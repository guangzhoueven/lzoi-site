#include <bits/stdc++.h>
using namespace std;
using i64 = long long;

int main() {
	ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr);
	i64 n;
	double ms, ps;
	cin >> n >> ms >> ps;  // 线段数n，移动速度ms，打印速度ps
	
	vector<pair<array<i64, 2>, array<i64, 2>>> seg(n);
	vector<double> pt(n);  // 打印时间
	
	for (i64 i = 0; i < n; ++i) {
		auto& [p1, p2] = seg[i];
		cin >> p1[0] >> p1[1] >> p2[0] >> p2[1];
		pt[i] = hypot(p1[0] - p2[0], p1[1] - p2[1]) / ps;  // hypot‌：计算两点间欧式距离的函数sqrt((x2-x1)^2 + (y2-y1)^2)
	}
	
	auto dis = [](const auto& a, const auto& b) {
		return hypot(a[0] - b[0], a[1] - b[1]);
	};
	
	vector<i64> order(n);
	iota(order.begin(), order.end(), 0);  				// iota函数：用于生成连续数值序列
	double min_time = numeric_limits<double>::max();  	// 初始化最小时间为最大值
	
	do {
		for (i64 k = 0; k < (1 << n); k++) {
			double sum_time = 0;
			array<i64, 2> pos{0, 0};
			for (auto idx : order) {
				i64 start = (k >> idx) & 1;  				// 0-第1个端点，1-第2个端点开始
				auto& [p1, p2] = seg[idx];
				auto& from = (start == 0) ? p1 : p2;
				auto& to = (start == 0) ? p2 : p1;
				sum_time += dis(pos, from) / ms;
				sum_time += pt[idx];
				pos = to;
				if (sum_time >= min_time) break;
			}
			min_time = min(min_time, sum_time);
		}
	} while (next_permutation(order.begin(), order.end()));  // 生成下一个打印顺序排列
	cout << fixed << setprecision(20) << min_time << "\n";
	return 0;
}