#include <bits/stdc++.h>
using namespace std;

using i64 = long long;
template <typename T>  		// c++特有模板
struct Fenwick {
	int n;
	vector<T> a;    		// 树状数组

	Fenwick(int n_) : n(n_) {
		a.assign(n + 1, 0);	// 树状数组都为 1-based
	}

	void add(int p, T v) {	// 更新操作：不断 p += lowbit(p)，向上更新父节点
		for (; p <= n; p += p & -p) a[p] += v;
	}

	T get(int p) {			// 求前缀和: sum(a[1..p]), 不断 p -= lowbit(p)，从p点开始，累加子节点值
		T ans = 0;
		for (; p > 0; p -= p & -p) ans += a[p];
		return ans;
	}

	T get(int L, int R) {	// 求区间和(1-based): sum(a[1..R]) - sum(a[1..(L-1)])
		return get(R) - get(L - 1);
	}
};

int main() {
	ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr);
	int n, m,  op, L, R;					// 数列长度n、操作数m、操作类型op、区间[L,R]
	cin >> n >> m;

	Fenwick<i64> bit(n);  					// 构建树状原始数组
	for (int i = 1; i <= n; i++) {			// 初始化数列
		int t;
		cin >> t;
		bit.add(i, t);  					// 将初始值加入树状数组
	}

	while (m--) {							// m 为操作次数
		cin >> op >> L >> R;  				// 操作类型op、区间左端点L=x、右端点R=k
		if (op == 1) bit.add(L, R);			// 操作1：单点增加
		else cout << bit.get(L, R) << "\n";	// 操作2：求前缀和
	}
	return 0;
}