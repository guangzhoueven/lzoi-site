#include <bits/stdc++.h>
using namespace std;

using i64 = long long;
template <typename T>  		// C++模板，支持多种数据类型
struct Fenwick {
	int n;
	vector<T> a;        	// 树状数组存储（1-based索引）

	Fenwick(int n_) : n(n_) {
		a.assign(n + 1, 0); // 初始化树状数组
	}

	void add(int p, T v) {	// 更新操作：不断 p += lowbit(p)，从p点开始，向上更新父节点
		for (; p <= n; p += p & -p) a[p] += v;
	}

	T get(int p) {			// 求前缀和: sum(a[1..p]), 不断 p -= lowbit(p)，从p点开始，累加子节点值
		T ans = 0;
		for (; p > 0; p -= p & -p) ans += a[p];
		return ans;
	}
};

int main() {
	ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr);
	int n;
	cin >> n;

	vector<int> a(n), b(n);  		// 原始数组和离散化数组
	for (int i = 0; i < n; i++) {
		cin >> a[i];
		b[i] = a[i];  				// 复制数组用于离散化
	}

	// 离散化处理
	sort(b.begin(), b.end());		// 默认升序排序
	b.erase(unique(b.begin(), b.end()), b.end());	// unique()为去重函数
	int m = b.size();  				// 离散化后的数值范围

	Fenwick<int> bit(m);  			// 初始化树状数组
	i64 ans = 0;  					// 逆序对总数

	for (int i = n - 1; i >= 0; i--) {	// 从右向左遍历，统计比当前数大的数的个数
		int x = lower_bound(b.begin(), b.end(), a[i]) - b.begin() + 1; // 获取离散化后的值（1-based）
		ans += bit.get(x - 1);  	// 统计比x大的数的个数
		bit.add(x, 1);  			// 将当前数加入树状数组
	}
	cout << ans << "\n";
	return 0;
}