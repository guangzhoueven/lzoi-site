#include <bits/stdc++.h>
using namespace std;
int main() {
	ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr);
	int n;
	cin >> n; 
	vector<vector<int>> grid(n, vector<int>(n));				// 构建n x n 方阵
	vector<vector<bool>> visited(n, vector<bool>(n, false));	// 构建访问标记
	for (int i = 0; i < n; i++) 
		for (int j = 0; j < n; j++)
			cin >> grid[i][j];		// 输出0-1数字方阵
	
	// 从每一个边界出发，找到所有和边界连通的0，那么剩下的0就在闭合圈内
	for (int i = 0; i < n; i++) {
		for (int j = 0; j < n; j++) {
			// 边界检查
			if ((i == 0 || i == n - 1 || j == 0 || j == n - 1) && grid[i][j] == 0 && !visited[i][j]) {
				queue<pair<int, int>> q;
				q.push({i, j});
				visited[i][j] = true;
				
				while(!q.empty()) {
					auto [x, y] = q.front();
					q.pop();
					vector<int> dx = {-1, 0, 1,  0};
					vector<int> dy = {0,  1, 0, -1};
					for (int k = 0; k < 4; k++) {
						int nx = x + dx[k], ny = y + dy[k];
						// 边界检查
						if (nx >= 0 && nx < n && ny >= 0 && ny < n && grid[nx][ny] == 0 && !visited[nx][ny]) {
							visited[nx][ny] = true;
							q.push({nx, ny});
						}
					}
				}
			}
		}
	}
	
	// 将未被访问的0替换为2
	for (int i = 0; i < n; i++) {
		for (int j = 0; j < n; j++) {
			if (grid[i][j] == 0 && !visited[i][j]) {
				grid[i][j] = 2;
			}
		}
	}
	// 输出结果
	for (int i = 0; i < n; i++) {
		for (int j = 0; j < n; j++) {
			cout << grid[i][j] << " ";
		}
		cout << "\n";
	}
	return 0;
}