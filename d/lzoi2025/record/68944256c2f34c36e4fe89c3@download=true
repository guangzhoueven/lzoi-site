#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int INF = INT_MAX;
int h, w;
int GetPath(vector<vector<char>>& g, int sx, int sy, int ex, int ey) {
	vector<int> dx = {1,  0, 0, -1};
	vector<int> dy = {0, -1, 1,  0};
	vector<vector<vector<int>>> d(h, vector<vector<int >> (w, vector<int>(4, INF)));
	queue<tuple<int, int, int>> q;
	for(int i = 0; i < 4; i++) 	d[sx][sy][i] = 0, q.push({sx, sy, i});

	while(!q.empty()) {
		auto [x, y, p] = q.front();
		q.pop();
		for(int k = 0; k < 4; k++) {
			int nx = x + dx[k], ny = y + dy[k];					// ↓障碍↓
			if((nx < 0 || nx >= h || ny < 0 || ny >= w) || (g[nx][ny] == 'x') ) continue;
			// ↓ +0不用转弯，否则+1要转弯 ↓
			int tmp = d[x][y][p] + (p != k);
			if (tmp < d[nx][ny][k]) {
				d[nx][ny][k] = tmp;
				q.push({nx, ny, k});
			}
		}
	}
	int ans = INF;
	for (int i = 0; i < 4; i++) ans = min(ans, d[ex][ey][i]);	// 4个方向都有可能到达终点
	return (ans == INF ? -1 : ans);
}

int main() {
	ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr);
	int n, sx = 0, sy = 0, ex = 0, ey = 0;
	cin >> n;
	h = n, w = n;
	vector<vector<char>> g(h, vector<char>(w));
	for (int i = 0; i < h; i++) {
		for (int j = 0; j < w; j++) {
			cin >> g[i][j];
			if (g[i][j] == 'A') sx = i, sy = j;
			if (g[i][j] == 'B') ex = i, ey = j;
		}
	}
	cout << GetPath(g, sx, sy, ex, ey) << "\n";
	return 0;
}
