#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N = 15, INF = INT_MAX;
using t4i = tuple<int, int, int, int>;
int d[N][N][N][N];
t4i p[N][N][N][N];
int h, w;
string GetPath(vector<string>& g, int px, int py) {
	int bx, by, tx, ty;
	for (int i = 0; i < h; i++) {
		for (int j = 0; j < w; j++) {
			if (g[i][j] == '$') bx = i, by = j;
			if (g[i][j] == '.') tx = i, ty = j;
		}
	}

	// 按照字典序：D < L < R < U
	vector<int> dx = {1,  0, 0, -1};
	vector<int> dy = {0, -1, 1,  0};
	vector<string> f = {"D", "L", "R", "U"};

	for (int x = 0; x < h; x++) {
		for (int y = 0; y < w; y++) {
			for (int u = 0; u < h; u++) {
				for (int v = 0; v < w; v++) {
					d[x][y][u][v] = INF;
					p[x][y][u][v] = {-1, -1, -1, -1};
				}
			}
		}
	}

	d[px][py][bx][by] = 0;
	queue<t4i> q;
	q.push({px, py, bx, by});
	while (!q.empty()) {
		auto [px, py, bx, by] = q.front();
		q.pop();

		for (int k = 0; k < 4; k++) {
			// 玩家的新位置
			int pu = px + dx[k], pv = py + dy[k];
			if ((pu < 0 || pu >= h || pv < 0 || pv >= w) || (g[pu][pv] == '#')) continue;

			// 箱子的新位置
			int bu = bx, bv = by;
			if (pu == bx && pv == by) {	// 箱子被推动1下
				bu = bx + dx[k], bv = by + dy[k];             //    ↓有障碍↓
				if ((bu < 0 || bu >= h || bv < 0 || bv >= w) || (g[bu][bv] == '#')) continue;
			}

			if (d[pu][pv][bu][bv] != INF) continue;     // 有其他更短路径

			d[pu][pv][bu][bv] = d[px][py][bx][by] + 1;  // 更新 d[u][v]
			p[pu][pv][bu][bv] = {px, py, bx, by};       // 记录到达 (u, v) 的方向

			q.push({pu, pv, bu, bv});
		}
	}

	int ex = -1, ey = -1, dis = INF;
	for (int i = 0; i < h; i++)  {
		for (int j = 0; j < w; j++) {
			if (d[i][j][tx][ty] < dis) {
				dis = d[i][j][tx][ty];
				ex = i, ey = j;
			}
		}
	}

	if (ex == -1) return "-1";	// 终点不可达

	string Path;
	int x = ex, y = ey, u = tx, v = ty;
	while (!(x == px && y == py && u == bx && v == by)) {
		auto [a, b, c, d] = p[x][y][u][v];
		if (x == a + 1) Path += "D";
		else if (x == a - 1) Path += "U";
		else if (y == b + 1) Path += "R";
		else if (y == b - 1) Path += "L";
		x = a, y = b, u = c, v = d;
	}
	
	reverse(Path.begin(), Path.end());	// 反转字符串
	return Path;
}
int main() {
	ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr);
	int px, py;
	cin >> h >> w >> px >> py;
	vector<string> g(h);
	for (int i = 0; i < h; i++) cin >> g[i];
	cout << GetPath(g, px, py);
	return 0;
}