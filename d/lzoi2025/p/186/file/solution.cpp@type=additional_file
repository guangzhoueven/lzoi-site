#include <bits/stdc++.h>
using namespace std;

using i64 = long long;

vector<i64> solve(vector<int>& a, vector<vector<int>>& q) {
    int n = a.size(), m = q.size();

    // p[i]: 表示最大的下标, 是的从 a[i] 到 a[p[i]] 是稳定子数组
    // p[] 数组肯定是单调不降的
    vector<int> p(n + 1);
    for (int i = 1, j = 1; i <= n; i++, j = max(j, i)) {
        while (j + 1 <= n && a[j] >= a[j - 1]) j++;
        p[i] = j;
    }
    vector<i64> f(n + 1, 0);
    for (int i = 1; i <= n; i++) f[i] = f[i - 1] + p[i] - i + 1;

    vector<i64> ans(m, 0);
    for (int i = 0; i < m; i++) {
        i64 u = q[i][0] + 1, v = q[i][1] + 1, d = v - u + 1;
        if (p[u] >= v) ans[i] = (1 + d) * d / 2;
        else if (p[v] <= v) ans[i] = f[v] - f[u - 1];
        else {
            int l = u, r = v;
            while (l != r) {
                int mid = (l + r) >> 1;
                if (p[mid] >= v) r = mid;
                else l = mid + 1;
            }
            ans[i] = f[l - 1] - f[u - 1];
            d = v - l + 1;
            ans[i] += (1 + d) * d / 2;
        }
    }
    return ans;
}

int main() {	
    ios::sync_with_stdio(false);
    cin.tie(0); cout.tie(0);
    
    int n, m;
    cin >> n >> m;
    vector<int> a(n);
    for (int i = 0; i < n; i++) cin >> a[i];

    vector<vector<int>> q(m, vector<int>(2));
    for (int i = 0; i < m; i++) cin >> q[i][0] >> q[i][1];
    
    vector<i64> ans = solve(a, q);
    for (int i = 0; i < m; i++) cout << ans[i] << " \n"[i == m - 1];

    return 0;
}