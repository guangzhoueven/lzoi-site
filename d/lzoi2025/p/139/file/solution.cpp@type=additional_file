#include <bits/stdc++.h>
using namespace std;

using i64 = long long;
using pii = pair<i64, i64>;
const int N = 5000000;

vector<int> w(N + 1, 1);

/*------------------------------------------- 欧拉筛 begin ----------------------------------------------*/
// oiwiki: https://oiwiki.org/math/number-theory/sieve/

// 返回不少过 n 以内的质数, 时间复杂度 O(n)
// 在 n = 10^7 时更快
vector<int> euler(int n) {
	// is_p[i] = true, 表示 i 是质数
	vector<bool> is_p(n + 1, true);
	vector<int> p;
	
	for (int i = 2; i <= n; i++) {
		if (is_p[i]) p.push_back(i), w[i] = i;
		for (int j = 0; j < (int) p.size() && i * p[j] <= n; j++) {
			is_p[i * p[j]] = false;
			w[i * p[j]] = p[j];
			
			// 说明 p[j] 是 i 的约数
			// 没有必要再往后枚举比 p[j] 大的质数了, 保证每个合数都被最小的质因子筛掉
			if (i % p[j] == 0) break;
		}
	}
	return p;
}

/*------------------------------------------- 欧拉筛 end -------------------------------------------------*/

int main() {	
	ios::sync_with_stdio(false);
	cin.tie(nullptr); cout.tie(nullptr);
	
	vector<int> p = euler(N);
//	for (int i = 2; i <= 100; i++) cout << "i= " << i << ", w[i]= " << w[i] << '\n';
	
	int T, n;
	cin >> T;
	while (T--) {
		cin >> n;
		vector<int> a(n);
		map<int, int> sum;
		for (int i = 0; i < n; i++) cin >> a[i];

		auto gao = [&]() -> bool {
			if (n & 1) return true;
			if (n == 2) return a[0] == a[1];
			for (int x : a) {
				while (x != 1) {
					int cnt = 0, d = w[x];
					while (w[x] == d) cnt++, x /= w[x];
					sum[d] += cnt;
				}
			}
			for (auto [d, s] : sum) {
				if (s & 1) return false;
			}
			return true;
		};
		cout << (gao() ? "YES" : "NO") << '\n';
		
	}
	return 0;
}